// Generated by CoffeeScript 1.6.2
var checkTimeOut, io, master, projectSet,
  __hasProp = {}.hasOwnProperty;

io = require('socket.io');

projectSet = {};

master = false;

checkTimeOut = function(project) {
  if (!projectSet[project]) {
    return;
  }
  if (projectSet[project].intervalId) {
    clearInterval(projectSet[project].intervalId);
  }
  return projectSet[project].intervalId = setInterval((function() {
    if (!projectSet[project]) {
      return;
    }
    projectSet[project].client.emit("syncEnd", "同步超时,可能造成原因：1.没有服务器订阅该项目2.服务器中断");
    return projectSet[project] = null;
  }), 1000 * 60 * 3);
};

exports.getConnSlaves = function() {
  var slave, slaveid, _ref, _results;

  _ref = master.sockets.sockets;
  _results = [];
  for (slaveid in _ref) {
    if (!__hasProp.call(_ref, slaveid)) continue;
    slave = _ref[slaveid];
    _results.push({
      'server': slave.endpoint,
      watch: slave.watchList
    });
  }
  return _results;
};

exports.listen = function(server) {
  if (appConfig.runAs !== "master") {
    return;
  }
  console.log(" 作为" + appConfig.runAs + "运行");
  exports.master = master = io.listen(server, {
    'log level': 0
  });
  return master.sockets.on('connection', function(socket) {
    var address;

    address = socket.handshake.address;
    socket.endpoint = address.address + ":" + address.port;
    socket.watchList = [];
    console.log(socket.endpoint + " 成功连接");
    socket.on('syncAll', function(project) {
      var slave, slaveid, _ref;

      if (projectSet[project]) {
        return socket.emit("syncEnd", "服务器正在同步,请过段时间在提交");
      }
      project = project.toLowerCase();
      projectSet[project] = {
        client: socket,
        slaves: {}
      };
      checkTimeOut(project);
      _ref = master.sockets.sockets;
      for (slaveid in _ref) {
        if (!__hasProp.call(_ref, slaveid)) continue;
        slave = _ref[slaveid];
        if (slave.isSlave && !slave.disconnected && slave.id !== socket.id) {
          if (!projectSet[project].slaves[slave.endpoint]) {
            projectSet[project].slaves[slave.endpoint] = 1;
          }
        }
      }
      return socket.broadcast.emit('sync', project);
    });
    socket.on('master', function(watchs) {
      socket.isSlave = true;
      if (watchs) {
        return socket.watchList = watchs;
      }
    });
    socket.on('notExist', function(data) {
      var clients, endpoint, project;

      project = data.project;
      if (projectSet[project] === null) {
        return;
      }
      delete projectSet[project].slaves[socket.endpoint];
      clients = (function() {
        var _ref, _results;

        _ref = projectSet[project].slaves;
        _results = [];
        for (endpoint in _ref) {
          if (!__hasProp.call(_ref, endpoint)) continue;
          _results.push(endpoint);
        }
        return _results;
      })();
      if (clients.length === 0) {
        projectSet[project].client.emit("syncEnd", "所有服务器同步完成");
        if (projectSet[project].intervalId) {
          clearInterval(projectSet[project].intervalId);
        }
        return projectSet[project] = null;
      }
    });
    socket.on('syncing', function(data) {
      var project;

      project = data.project;
      if (projectSet[project] === null) {
        return;
      }
      if (projectSet[project].slaves[socket.endpoint] === 2) {
        return;
      }
      projectSet[project].slaves[socket.endpoint] = 2;
      projectSet[project].client.send("正在同步：" + socket.endpoint + "\n");
      console.log("正在同步：" + socket.endpoint);
      return checkTimeOut(project);
    });
    socket.on("disconnect", function() {
      return console.log(socket.endpoint + "已经断开连接");
    });
    socket.on('synced', function(data) {
      var clients, endpoint, project;

      project = data.project;
      if (!projectSet[project]) {
        return;
      }
      if (projectSet[project].slaves[socket.endpoint]) {
        projectSet[project].client.send(socket.endpoint + data.result + "\n");
        console.log(socket.endpoint + data.result);
        delete projectSet[project].slaves[socket.endpoint];
        console.log('剩余客户端' + JSON.stringify(projectSet[project].slaves));
      }
      checkTimeOut(project);
      clients = (function() {
        var _ref, _results;

        _ref = projectSet[project].slaves;
        _results = [];
        for (endpoint in _ref) {
          if (!__hasProp.call(_ref, endpoint)) continue;
          _results.push(endpoint);
        }
        return _results;
      })();
      if (clients.length === 0) {
        projectSet[project].client.emit("syncEnd", "所有服务器同步完成");
        if (projectSet[project].intervalId) {
          clearInterval(projectSet[project].intervalId);
        }
        return projectSet[project] = null;
      }
    });
    return socket.on('message', function(data) {
      return console.log(data);
    });
  });
};
